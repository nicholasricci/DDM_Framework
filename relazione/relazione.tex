\documentclass[a4paper,11pt]{report}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage[nouppercase]{frontespizio}

%\title{Relazione Finale di Tirocinio}
%\author{Nicholas Ricci}
%\date{08/09/2014}

\newcommand{\customfigure}[3]{
  \begin{figure}[ht]
    \centering
    \includegraphics[scale=0.35, width=125mm]{#1}
    \caption{#2}
    \label{fig:#3}
  \end{figure}
}

\begin{document}

\begin{frontespizio}
\Universita{Universit\`a di Bologna}
%\Logo{duck}
\Facolta{Scienze Matematiche, Fisiche e Naturali}
\Corso[Laurea Triennale]{Scienze e Tecnologie Informatiche}
\Annoaccademico{25/11/2013--?}
%\Titoletto{}
\Titolo{Relazione Finale di Tirocinio}
\Sottotitolo{Framework per Data Distribution Management}
\Candidato[0000624982]{Ricci Nicholas}
\Relatore{Gabriele D'Angelo}
\NRelatore{Tutor Accademico}{Tutor Accademici}
\end{frontespizio}

\tableofcontents

\chapter{Obiettivi}

Dato un sistema basilare di comparazione tra algoritmi di DDM creare un framework
per poter gestire vecchi e nuovi algoritmi con un input e un output uguale.
Il framework dev'essere in grado di:
\begin{enumerate}
 \item gestire sorgenti di nuovi e vecchi algoritmi;
 \item poter comparare nuovi e vecchi algoritmi;
 \item restituire in output i risultati in una cartella apposita.
\end{enumerate}

\customfigure{./immagini/obiettivi.png}{Framework schema}{obiettivi}

\chapter{Cos'\`e il Data Distribuited Management?}

``The goal of HLA Data Distribution Management (DDM) services is to limit 
the messages received by federates in large distributed federations to 
those messages of interest in order to reduce (1) the data set required 
to be processed by the receiving federate and (2) the message traffic 
over the network. If this functionality is provided in a manner that 
is efficient, it can significantly improve the performance and scalability 
of large distributed federations. We provide an overview of the fundamental 
DDM mechanisms, routing spaces with update and subscription regions, 
and show how DDM services interoperate with other HLA services to allow 
federates to discover objects and attributes of interest. We proceed 
to derive strategies for implementing physically correct filters to account 
for network latencies and object movement in the virtual environment. 
These strategies rely on mathematically derived extensions of update and 
subscription regions to optimize filter efficiency.'' citazione L. Morse ~\cite{Morse97datadistribution}

\chapter{Analisi del sistema}

All'interno del sistema di base sono presenti i seguenti oggetti:
\begin{enumerate}
 \item batch-build\_ALL.sh: esegue il comando ``make'' per gli algoritmi ``interval\_tree'', ``sort\_matching\_standard'' 
 e la cartella ``utils'';
 \item batch-clean\_ALL.sh: esegue il comando ``make clean'' per gli algoritmi ``interval\_tree'', 
 ``sort\_matching\_standard'' e ``utils''. Rimuove i file ``allspeed*.txt'', ``*.ps'', ``*.eps'' dalla cartella
 ``\_graphs'', tutti i file ``*.txt'' dalla cartella ``\_result'' e tutta la cartella ``\_bin'';
 \item batch-graphs\_ALL.sh: esegue lo script di shell ``batch-speedup.sh'' dopodich\`e sposta i file di risultato
 nella cartella ``\_graphs/'' e crea i grafici con ``gnuplot'' per ogni file ``*.gp'';
 \item batch-speedup.sh: Per ogni algoritmo e per ogni alfa, finch\`e gli ``extents'' sono minori di ``max extents'' 
 allora prepara lo speedup per ogni file (algoritmo sequenziale / algoritmo parallelo);
 \item configuration.sh: contiene alcune variabili per gli shell script come ``start\_extents'', ``max\_extents'',
 ``step\_size'', ``alfa'', ``alfas\_par'', \newline``par\_algorithms'';
 \item batch-tests\_ALL.sh: esegue prima lo script ``batch-tests\_seq.sh'' (sequenziale) e successivamente
 ``batch-tests\_par.sh'' (parallelo)
 \item batch-tests\_ALL-par.sh: esegue ``batch-tests\_brute\_mp.sh'' e ``batch-test\_interval\_mp.sh'' in parallelo,
 con pi\`u core;
 \item batch-tests\_ALL-seq.sh: esegue ``batch-tests\_brute.sh'', \newline``batch-tests\_interval.sh'' e ``batch-tests\_sort.sh''
 in modo sequenziale;
 \item batch-tests\_brute.sh: crea la cartella ``\_result'' e ``\_graphs'' se non esistono. Per ogni alfa all'interno 
 della variabile ALFAS crea un file con nome ``exec\_time\_BRUTE\_alfa\_\$ALFA.txt''. Parte da un numero prefissato di
 extents e finch\`e non raggiunge un numero massimo di extents esegue 30 run dello stesso algoritmo prendendo cos\`i 
 il tempo medio. Ogni tempo medio viene salvato in un file chiamato ``exec\_time\_BRUTE\_alfa\_\$ALFA.txt'' e alla
 fine il file viene spostato nella cartella ``\_graphs''. Ad ogni extent viene spostato il file ``brute\_force.txt'' 
 nella cartella ``\_result'' che contiene l'esecuzione con quel determinato numero di extents, alfa e dimensione;
 \item batch-tests\_brute\_mp.sh: la stessa cosa di ``batch-tests\_brute.sh'' ma la cartella sorgente \`e 
 brute\_force\_mp al posto di brute\_force;
 \item batch-tests\_interval.sh: la stessa cosa di ``batch-tests\_brute.sh'' ma la cartella sorgente \`e interval al
 posto di brute\_force;
 \item batch-tests\_interval\_mp.sh: la stessa cosa di ``batch-tests\_brute.sh'' ma la cartella sorgente \`e 
 interval\_mp al posto di brute\_force;
 \item batch-tests\_interval\_mp\_3d.sh: la stessa cosa di \newline ``batch-tests\_brute.sh'' ma la cartella sorgente \`e 
 interval\_mp\_3d al posto di brute\_force;
 \item batch-tests\_sort.sh: la stessa cosa di ``batch-tests\_brute.sh'' ma la cartella sorgente \`e 
 sort al posto di brute\_force;
\end{enumerate}

\bibliography{bibliografia}{}
\bibliographystyle{plain}

\end{document}
